


/*
Алгоритм поиска места в сортированном одноуровневом списке

В функцию передаем список и вставляемый элемент, если любой из них нулевой, 
то генерируем исключение, проверяем поочередно
Если список несортирован, то генерируем исключение

Если у текущего узла списка нет последователя, то возвращаем текущий узел

Если последователь есть
Пока это так

Цикл открыт
Сравниваем ключ последователя с ключем вставляемого узла
Если ключ последователя больше, то возвращаем текущий узел
Если ключ последователя меньше, то сдвигаем список вправо
Цикл закрыт

Возвращаем текущий узел
*/
Link* insert_place(Link* e, Link* p)
{
	if (!e) throw SL_exc{"fnc() is - insert_plase, first arguments is null"};
	if (!p) throw SL_exc{"fnc() is - insert_plase, second arguments is null"};
	if (!is_ordered(e)) throw SL_exc{"fnc() is - insert_plase, list unsorted"};
	
	while (e->next())
	{
		if (e->next()->what_key() > p->what_key()) return e;
		else e = e->next();
	}
	return e;
}


/*
Алгоритм поиска места для вставки в сортированом многоуровневом списке

Передаем 2 аргумента: список и элемент для вставки
если любой из них нулевой, 
то генерируем исключение, проверяем поочередно

Если уровня внизу нет, то возвращаем место для вставки на данном уровне - функцию insert_place()

Цикл открыт

Пока есть уровень ниже
Списку присваивается значение места для вставки на данном уровне - функция insert_place(p);
После чего идем вниз

Цикл закрыт

возвращаем место для вставки на данном уровне - функцию insert_place()

*/

Link* insert_level(Link* e, Link* p)
{
	if (!e) throw SL_exc{"fnc() is - insert_level, first arguments is null"};
	if (!p) throw SL_exc{"fnc() is - insert_level, second arguments is null"};
	
	while (e->get_down())
	{
		e = insert_place(e,p);
		e = e->get_down();
	}
	
	return insert_place(e,p);
}


/*
Алгорим вычисления числа подбрасываний

Поскольку число подбрасываний случайно, то просто вычисляем случайное значение в пределах 15 чисел
Как семя используем случайное число в пределах 150 чисел+clock()
*/

int flip()
{
	return rand()%10;
}

















