/*
//Название программы: Я не знаю, зачем столько времени на неё угробил приводя её впорядок, полезная функция заняла 30 минут, остальное отделка...
//Цель программы: Заебать меня
//Автор: Антонюк И.В.
//Дата начала написания: 07.12.2016
//Дата окончания написания: 07.12.2016
//Номер версии:1
//Фрагменты кода, которые могут вызвать проблемы: Обработка ошибок
//Основные идеи проекта:
//Способ организации кода:
//Предположения о вводных данных:



Какая задача должна быть решена? Первое, о чем надо задуматься:
1. Уточнение задачи;
2. Что программа должна делать для пользователя?
3. Ясна ли постановка задачи?
4. Выглядит ли задача решаемой при имеющихся времени, умении и
инструментах? 


1.  Постарайтесь разбить программу на небольшие части. Даже самаямаленькая программа, решающая реальную задачу. достаточно велика,чтобы ее можно бьuю разбить на части.
1.1 Знаете ли вы , какие инструменты, библиотеки и другие подобные
ресурсы могут вам помочь? 
1.2 Проанализируйте части решения, которые можно описать отдельно(и потенциально использовать в разных местах программы или
даже в других программах). 
1.3. Создавайте небольшие и ограниченные версии программы, решающие ключевые части вашей задачи. Начиная работу, мы редко хорошо понимаем задачу. Мы часто думаем, что все прекрасно понимаем
1.4  Итак, пишите небольшие и ограниченные версии, чтобы достичь следующих целей:
1.4.1 выявить проблемы в понимании, идеях и требуемом инструментар
1.4.2 выявить необходимые изменения в формулировке задачи , чтобыупростить рабоrу с ней. 
• Иногда такая ограниченная первоначальная версия называется прототипом
(prototype). Если первая версия не работает или работает
очень плохо (что очень вероятно), отбросьте ее и создайте другую. Повторяйте этот процесс до тех пор. пока не достигнете желаемого. Не пытайтесь навести порядок в имеющейся путанице; со временем она
будет лишь возрастать.
1.4.3 Создавайте полномасштабное решение, в идеале используя части первоначальной версии. Недостижимый идеал заключается в том, что программа должна вырастать из отдельных компонентов, а не быть написана вся и сразу в один присест. В противном случае придется рассчитывать на чудо и надеяться, что непроверенная идеяокажется работоспособной и позволит достичь желаемого.


*/






/*
Написать функцию, которая для двух
переданных объектов типа vector <double>
price и weight, вычисляет значение,
равное сумме всех произведений 
price[i]*weight[i].
Проверить выполнениея условия
weight.size() == price.size();
*/


#include <std_lib_facilities.h>
double summ_w_p (vector<double>weight, vector<double>price) { //суммируем произведения элементов векторов
	double sum = 0;
	if (weight.size()!=price.size()) error ("summ :: volume of weight != volume of price\n");
	for (int i =0; i<weight.size();++i) sum+=weight[i]*price[i];
	return sum;
	} //закрывает summ_w_p
void insert (vector<double>&weight, vector<double>&price) { //вводим элементы в векторы
	
	double w = 0;
	double p = 0;
	bool c = true;
	while (c==true) {
	cout << "weight - ";
	cin >> w;
	if (!cin) { //если что пошло не так
		cin.clear(); // чистим поток
		error ("wrong value of weight");
		} // закрывает if
	weight.push_back(w);
	cout << "price - ";
	cin >> p;
	if (!cin) {
		cin.clear(); 
		error ("wrong value of price");
		}// закрывает if
	if (w==0&&p==0) c=false;
	price.push_back(p);
	}//закрывает while
	
}//закрывает функцию
void cleaning (vector<double>&weight, vector<double>&price) { //чистим вектора
	weight.clear();
	price.clear ();
} // закрывает функцию
void ignoring () { //перехватываем неправильный ввод
	string c;
	cin >>c;
   } // закрывает функцию
int main () 
try{
	cout << "Insert weight and price, insert '0' weight and price for see result \n";
	vector<double>weight;
	vector<double>price;
	while (true) {
	try {
	insert(weight, price);
	double sum = summ_w_p(weight,price);
	cout << sum << '\n';
	cleaning(weight,price);
	} //закрывает блок try
	catch (exception& e) {
	cerr << e.what() << '\n';
	ignoring ();
	} ////закрывает catch
	}  //закрывает while
	keep_window_open();
	return 0;
	}//закрывает try
catch (exception& e) {
	cerr << e.what() << '\n';
	keep_window_open("~~");
	return 1;
} //закрывает catch
catch (...) {
	cerr << "Ups....." << '\n';
	keep_window_open("~~");
	return 2;
} //закрывает catch