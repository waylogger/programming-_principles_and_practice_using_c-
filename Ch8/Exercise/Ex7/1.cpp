/*
//Название программы: Сортируем имена и возраста
//Цель программы: Отработать передачу значения по ссылке и улучшить работу с векторами
//Автор: Антонюк И.В.
//Дата начала написания: 06.12.2016
//Дата окончания написания: 07.12.2016
//Номер версии: 1
//Фрагменты кода, которые могут вызвать проблемы: везде где были ссылки
//Основные идеи проекта: устанавливаем зависимость между двумя векторами
//Способ организации кода:
//Предположения о вводных данных: string и double
Грамматика:
Псевдокод:
Какая задача должна быть решена? Первое, о чем надо задуматься:
1. Уточнение задачи;
2. Что программа должна делать для пользователя?
3. Ясна ли постановка задачи?
4. Выглядит ли задача решаемой при имеющихся времени, умении и
инструментах? 
1.  Постарайтесь разбить программу на небольшие части. Даже самаямаленькая программа, 
решающая реальную задачу. достаточно велика,чтобы ее можно бьuю разбить на части.
1.1 Знаете ли вы , какие инструменты, библиотеки и другие подобные
ресурсы могут вам помочь? 
1.2 Проанализируйте части решения, которые можно описать 
отдельно(и потенциально использовать в разных местах программы или
даже в других программах). 
1.3. Создавайте небольшие и ограниченные версии программы,
 решающие ключевые части вашей задачи. Начиная работу, мы редко 
 хорошо понимаем задачу. Мы часто думаем, что все прекрасно понимаем
1.4  Итак, пишите небольшие и ограниченные версии, чтобы достичь следующих целей:
1.4.1 выявить проблемы в понимании, идеях и требуемом инструментар
1.4.2 выявить необходимые изменения в формулировке задачи , чтобыупростить рабоrу с ней. 
• Иногда такая ограниченная первоначальная версия называется прототипом
(prototype). Если первая версия не работает или работает
очень плохо (что очень вероятно), отбросьте ее и создайте другую. 
Повторяйте этот процесс до тех пор. пока не достигнете желаемого. 
Не пытайтесь навести порядок в имеющейся путанице; со временем она
будет лишь возрастать.
1.4.3 Создавайте полномасштабное решение, в идеале 
используя части первоначальной версии. Недостижимый идеал заключается в том, 
что программа должна вырастать из отдельных компонентов, а не быть написана вся и сразу в один присест. 
В противном случае придется рассчитывать на чудо и надеяться, что непроверенная идеяокажется работоспособной и 
позволит достичь желаемого.
*/


/*
Условия задачи
1. Считать 5 имён в вектор vector<string>
2. Предложить пользователю указать возраст названных людей;
3. Записать имена в vector<double>age;
4. Вывести на печать все 5 пар;
5. Отсортировать имена (sort(name.begin(),name.end()))
6. Вывести на печать пары (name [i], age [i])
Сложность в том, чтобы получить вектор age, в котором порядок следования 
элементов соответствовал бы порядку следования элементов вектора name;
Указание: перед сортировкой вектора name необходимо содтать его копию и использовать ее для 
получения упорядоченного вектора age после сортировки вектора name
7. Выполнить упражнение снова разрешив использование произвольного количества имен.
*/


#include <std_lib_facilities.h>
namespace cargo { //создаем пространство имён с векторами
vector<string>name;
vector<string>difname;
vector<double>age;
}
using namespace cargo; //если встречаем неизвестное имя, то смотрим тут
void communication_name () { //сообшение
	cout << "Insert list of names for sorting\n";
	cout << "'0' - end of insert, 'exit' - for exit of programm" <<"\n"; //справка по работе
	
}
void communication_age () { //сообшение
	cout << "Insert age of this people:\n";
}
void communication_sort () {//сообшение
	cout << "		Sorting.....\n";
}
void pushing_name () {//вносим имена
	string s = " ";
	while (cin>>s) {
		if (s=="0") return; //прекращаем ввод имён
		if(s=="exit") exit(0); //закрываем программу
		name.push_back(s);
		}
}
void pushing_age () {//вносим возраст
	double s = 0;
	for (int i=0; i<name.size();++i) {
	cout << name[i] << " - "; //выводим имя, чей возраст принимаем
	cin >> s;
	if(!cin) { //если ввод не удался
		cin.clear();  //очищаем поток, чтобы избежать "пробежки в дно"
		error ("pushing_age :: wrong value, age must be a double");}
	if (s==0) return; //прекращаем ввод возрастов
	age.push_back(s);
	}
}
void vector_print (vector<string>name, vector<double>age) { //печатаем
	if (name.size()!=age.size()) error ("Volume error :: Less/more name/ages\n"); //врядли пригодится, срабатывает, если число имен и возрастов разнится
	for (int i = 0; i<name.size(); ++i) {cout << i+1 << ". - " << name [i] << " - " << age[i] << '\n';} //i+1 потому что 1-й элемент вектора имеет индекс 0, а нам нужен нормальный список
}
void copy_vector(vector<string>name,vector<string>&difname) { //копируем вектор
	difname=name;} //Элементарно, NB используем передачу значения по ссылке
void control_sort (vector<string>name, vector<string>difname, vector<double>&age) { //сортируем возраст
		vector<double>difage; //локальный вектор возрастов
	
		difage=age; //копируем возраста
		
for (int i =0; i<name.size(); ++i) { //берем первое имя
	for (int i2=0; i2<name.size();++i2) { //сравниваем с остальными
		if (difname[i]==name[i2]) age[i2]=difage[i]; //при совпадении имён меняем индекс возраста, но берем его из копии, так как оригинальный вектор изменился
		
		}
	}
}
void cleaning () { //очищаем векторы
	name.clear();
	age.clear();
				 }
void sorting () { //выполняем сортировку всего
communication_sort ();

sort(name.begin(),name.end());
control_sort (name, difname, age);
}
void pushing () { //выводим сообщения о вводе и выполняем его
communication_name ();
pushing_name ();
communication_age ();
pushing_age ();
				 }
int main () try {
		while (true) {
			try {
pushing (); // выводим сообщения о вводе и выполняем его
vector_print(name,age); //печатаем
copy_vector(name,difname); //копируем вектор
sorting (); //сортируем 
vector_print(name,age);//печатаем
cleaning (); //чистим
			}
	catch (exception& e) { //восстанавливаемся после ошибок
	cerr << e.what () << '\n';
	
						 }
					  }
			}
catch (exception& e) {
	cerr << e.what() << '\n';
	keep_window_open("~~");
}
catch (...){
	cerr << "Ups......\n";
	keep_window_open("~~");
}


























