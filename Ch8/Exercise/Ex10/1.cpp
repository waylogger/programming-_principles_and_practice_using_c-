/*
//Название программы: Транспортировка 
//Цель программы: отработать передачу значений по ссылке и через структуру
//Автор: Антонюк И.В.
//Дата начала написания: 08.12.2016
//Дата окончания написания: 08.12.2016
//Номер версии: 1
//Фрагменты кода, которые могут вызвать проблемы: 
//Основные идеи проекта:
//Способ организации кода:
//Предположения о вводных данных:



Какая задача должна быть решена? Первое, о чем надо задуматься:
1. Уточнение задачи;
2. Что программа должна делать для пользователя?
3. Ясна ли постановка задачи?
4. Выглядит ли задача решаемой при имеющихся времени, умении и
инструментах? 


1.  Постарайтесь разбить программу на небольшие части. Даже самаямаленькая программа,
решающая реальную задачу. достаточно велика,чтобы ее можно бьuю разбить на части.
1.1 Знаете ли вы , какие инструменты, библиотеки и другие подобные
ресурсы могут вам помочь? 
1.2 Проанализируйте части решения, которые можно описать отдельно(и потенциально использовать в разных местах программы или
даже в других программах). 
1.3. Создавайте небольшие и ограниченные версии программы, решающие ключевые части вашей задачи. Начиная работу,
 мы редко хорошо понимаем задачу. Мы часто думаем, что все прекрасно понимаем
1.4  Итак, пишите небольшие и ограниченные версии, чтобы достичь следующих целей:
1.4.1 выявить проблемы в понимании, идеях и требуемом инструментар
1.4.2 выявить необходимые изменения в формулировке задачи , чтобыупростить рабоrу с ней. 
• Иногда такая ограниченная первоначальная версия называется прототипом
(prototype). Если первая версия не работает или работает
очень плохо (что очень вероятно), отбросьте ее и создайте другую. Повторяйте этот процесс до тех пор.
 пока не достигнете желаемого. Не пытайтесь навести порядок в имеющейся путанице; со временем она
будет лишь возрастать.
1.4.3 Создавайте полномасштабное решение, в идеале используя части первоначальной версии. Недостижимый 
идеал заключается в том, что программа должна вырастать из отдельных компонентов, а не быть написана 
вся и сразу в один присест. В противном случае придется рассчитывать на чудо и надеяться, что непроверенная 
идеяокажется работоспособной и позволит достичь желаемого.

*/



/*
Написать функцию, которая находит
наименьший и наибольший элементы
вектора, являющегося ее аргументом,
а так же вычисляющую их среднее и
медианы.

Не использовать глобальные переменные;

Результаты можно развернуть в виде 
структуры struct, либо c помощью
механизма передачи аргументов по ссылке.
Какий из этих двух способов предпочесть и почему?



Что хотелось бы отметить: удобнее всего передавать значения используя обяъявление namespace, не нужно 
переживать о типах, просто задал. Но в условиях задания было указание использовать struct или ссылки
я использовал и то и другое.

*/

#include <std_lib_facilities.h>
struct numbers { // создаем структуру мобильных данных
	vector<double>mediana;
	int midle;
	double maxv;
	
};

	
numbers operations (vector<double>&dir) //производим все вычисления

{ //operations
numbers v;
double sums =0;
sort(dir.begin(),dir.end());
v.maxv=dir[dir.size()-1]; //вычисляем максимальное число: после сортировки оно будет крайним
for (int i = 0; i<dir.size();++i) 
{//for
sums+=dir[i];
v.midle=sums/dir.size(); //вычисляем среднее арифметическое
}//for

if (dir.size()%2==0)
{//if
v.mediana.push_back (dir[dir.size()/2-1]); //медиана
v.mediana.push_back (dir[dir.size()/2]);
}//if
if (dir.size()%2!=0) v.mediana.push_back(dir[dir.size()/2]); //медиана 
return v;
 }//operations
 
void print (vector<double>&dir)  //печатаем
{//print
numbers v = operations (dir);
cout << "Midle - " << v.midle << '\n';
cout << "Max - " << v.maxv << '\n'; 
for (int i = 0; i<v.mediana.size();++i)
cout << "Mediana - " << v.mediana[i] << ' ';
v.mediana.clear();
cout << '\n';
}//print
 
int main ()  
try { //try
	vector<double>todir{1,4,2,3,5,6,23,2,3,4,5,6,6,556,2,2,5554};
	operations (todir);
	print (todir);
	keep_window_open();
	} //try
	
	catch (exception& e) 
	{// catch
	cerr << e.what () << '\n';
	keep_window_open("~~");
	}// catch

catch (...)
{ //catch
cerr << "Ups......\n";
keep_window_open("~~");
}//catch	
	
	
	
	
	
	
	
	
	